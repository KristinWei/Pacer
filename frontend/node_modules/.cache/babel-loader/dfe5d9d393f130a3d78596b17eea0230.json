{"ast":null,"code":"import { parser } from '@lezer/python';\nimport { LRLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\n\nfunction indentBody(context, node) {\n  var base = context.lineIndent(node.from);\n  var line = context.lineAt(context.pos, -1),\n      to = line.from + line.text.length; // Don't consider blank, deindented lines at the end of the\n  // block part of the block\n\n  if (!/\\S/.test(line.text) && context.node.to < to + 100 && !/\\S/.test(context.state.sliceDoc(to, context.node.to)) && context.lineIndent(context.pos, -1) <= base) return null; // A normally deindenting keyword that appears at a higher\n  // indentation than the block should probably be handled by the next\n  // level\n\n  if (/^\\s*(else:|elif |except |finally:)/.test(context.textAfter) && context.lineIndent(context.pos, -1) > base) return null;\n  return base + context.unit;\n}\n/**\nA language provider based on the [Lezer Python\nparser](https://github.com/lezer-parser/python), extended with\nhighlighting and indentation information.\n*/\n\n\nvar pythonLanguage = /*@__PURE__*/LRLanguage.define({\n  parser: /*@__PURE__*/parser.configure({\n    props: [/*@__PURE__*/indentNodeProp.add({\n      Body: function Body(context) {\n        var _a;\n\n        return (_a = indentBody(context, context.node)) !== null && _a !== void 0 ? _a : context.continue();\n      },\n      IfStatement: function IfStatement(cx) {\n        return /^\\s*(else:|elif )/.test(cx.textAfter) ? cx.baseIndent : cx.continue();\n      },\n      TryStatement: function TryStatement(cx) {\n        return /^\\s*(except |finally:)/.test(cx.textAfter) ? cx.baseIndent : cx.continue();\n      },\n      \"TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \")\"\n      }),\n      \"DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \"}\"\n      }),\n      \"ArrayExpression ArrayComprehensionExpression\": /*@__PURE__*/delimitedIndent({\n        closing: \"]\"\n      }),\n      Script: function Script(context) {\n        if (context.pos + /\\s*/.exec(context.textAfter)[0].length >= context.node.to) {\n          var endBody = null;\n\n          for (var cur = context.node, to = cur.to;;) {\n            cur = cur.lastChild;\n            if (!cur || cur.to != to) break;\n            if (cur.type.name == \"Body\") endBody = cur;\n          }\n\n          if (endBody) {\n            var bodyIndent = indentBody(context, endBody);\n            if (bodyIndent != null) return bodyIndent;\n          }\n        }\n\n        return context.continue();\n      }\n    }), /*@__PURE__*/foldNodeProp.add({\n      \"ArrayExpression DictionaryExpression SetExpression TupleExpression\": foldInside,\n      Body: function Body(node, state) {\n        return {\n          from: node.from + 1,\n          to: node.to - (node.to == state.doc.length ? 0 : 1)\n        };\n      }\n    })]\n  }),\n  languageData: {\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"']\n    },\n    commentTokens: {\n      line: \"#\"\n    },\n    indentOnInput: /^\\s*([\\}\\]\\)]|else:|elif |except |finally:)$/\n  }\n});\n/**\nPython language support.\n*/\n\nfunction python() {\n  return new LanguageSupport(pythonLanguage);\n}\n\nexport { python, pythonLanguage };","map":null,"metadata":{},"sourceType":"module"}
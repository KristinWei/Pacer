{"ast":null,"code":"import _possibleConstructorReturn from \"/Users/kw/Desktop/cscc09/project-pacer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/kw/Desktop/cscc09/project-pacer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kw/Desktop/cscc09/project-pacer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createClass from \"/Users/kw/Desktop/cscc09/project-pacer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"/Users/kw/Desktop/cscc09/project-pacer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { Decoration, showPanel, EditorView, ViewPlugin, hoverTooltip, logException, gutter, showTooltip, getPanel, WidgetType, GutterMarker } from '@codemirror/view';\nimport { StateEffect, StateField, Facet, combineConfig, RangeSet } from '@codemirror/state';\nimport elt from 'crelt';\n\nvar SelectedDiagnostic = function SelectedDiagnostic(from, to, diagnostic) {\n  _classCallCheck(this, SelectedDiagnostic);\n\n  this.from = from;\n  this.to = to;\n  this.diagnostic = diagnostic;\n};\n\nvar LintState = /*#__PURE__*/function () {\n  function LintState(diagnostics, panel, selected) {\n    _classCallCheck(this, LintState);\n\n    this.diagnostics = diagnostics;\n    this.panel = panel;\n    this.selected = selected;\n  }\n\n  _createClass(LintState, null, [{\n    key: \"init\",\n    value: function init(diagnostics, panel, state) {\n      // Filter the list of diagnostics for which to create markers\n      var markedDiagnostics = diagnostics;\n      var diagnosticFilter = state.facet(lintConfig).markerFilter;\n      if (diagnosticFilter) markedDiagnostics = diagnosticFilter(markedDiagnostics);\n      var ranges = Decoration.set(markedDiagnostics.map(function (d) {\n        // For zero-length ranges or ranges covering only a line break, create a widget\n        return d.from == d.to || d.from == d.to - 1 && state.doc.lineAt(d.from).to == d.from ? Decoration.widget({\n          widget: new DiagnosticWidget(d),\n          diagnostic: d\n        }).range(d.from) : Decoration.mark({\n          attributes: {\n            class: \"cm-lintRange cm-lintRange-\" + d.severity\n          },\n          diagnostic: d\n        }).range(d.from, d.to);\n      }), true);\n      return new LintState(ranges, panel, findDiagnostic(ranges));\n    }\n  }]);\n\n  return LintState;\n}();\n\nfunction findDiagnostic(diagnostics) {\n  var diagnostic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  var after = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var found = null;\n  diagnostics.between(after, 1e9, function (from, to, _ref) {\n    var spec = _ref.spec;\n    if (diagnostic && spec.diagnostic != diagnostic) return;\n    found = new SelectedDiagnostic(from, to, spec.diagnostic);\n    return false;\n  });\n  return found;\n}\n\nfunction hideTooltip(tr, tooltip) {\n  return !!(tr.effects.some(function (e) {\n    return e.is(setDiagnosticsEffect);\n  }) || tr.changes.touchesRange(tooltip.pos));\n}\n\nfunction maybeEnableLint(state, effects) {\n  return state.field(lintState, false) ? effects : effects.concat(StateEffect.appendConfig.of([lintState, EditorView.decorations.compute([lintState], function (state) {\n    var _state$field = state.field(lintState),\n        selected = _state$field.selected,\n        panel = _state$field.panel;\n\n    return !selected || !panel || selected.from == selected.to ? Decoration.none : Decoration.set([activeMark.range(selected.from, selected.to)]);\n  }), hoverTooltip(lintTooltip, {\n    hideOn: hideTooltip\n  }), baseTheme]));\n}\n/**\nReturns a transaction spec which updates the current set of\ndiagnostics, and enables the lint extension if if wasn't already\nactive.\n*/\n\n\nfunction setDiagnostics(state, diagnostics) {\n  return {\n    effects: maybeEnableLint(state, [setDiagnosticsEffect.of(diagnostics)])\n  };\n}\n/**\nThe state effect that updates the set of active diagnostics. Can\nbe useful when writing an extension that needs to track these.\n*/\n\n\nvar setDiagnosticsEffect = /*@__PURE__*/StateEffect.define();\nvar togglePanel = /*@__PURE__*/StateEffect.define();\nvar movePanelSelection = /*@__PURE__*/StateEffect.define();\nvar lintState = /*@__PURE__*/StateField.define({\n  create: function create() {\n    return new LintState(Decoration.none, null, null);\n  },\n  update: function update(value, tr) {\n    if (tr.docChanged) {\n      var mapped = value.diagnostics.map(tr.changes),\n          selected = null;\n\n      if (value.selected) {\n        var selPos = tr.changes.mapPos(value.selected.from, 1);\n        selected = findDiagnostic(mapped, value.selected.diagnostic, selPos) || findDiagnostic(mapped, null, selPos);\n      }\n\n      value = new LintState(mapped, value.panel, selected);\n    }\n\n    var _iterator = _createForOfIteratorHelper(tr.effects),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var effect = _step.value;\n\n        if (effect.is(setDiagnosticsEffect)) {\n          value = LintState.init(effect.value, value.panel, tr.state);\n        } else if (effect.is(togglePanel)) {\n          value = new LintState(value.diagnostics, effect.value ? LintPanel.open : null, value.selected);\n        } else if (effect.is(movePanelSelection)) {\n          value = new LintState(value.diagnostics, value.panel, effect.value);\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return value;\n  },\n  provide: function provide(f) {\n    return [showPanel.from(f, function (val) {\n      return val.panel;\n    }), EditorView.decorations.from(f, function (s) {\n      return s.diagnostics;\n    })];\n  }\n});\n/**\nReturns the number of active lint diagnostics in the given state.\n*/\n\nfunction diagnosticCount(state) {\n  var lint = state.field(lintState, false);\n  return lint ? lint.diagnostics.size : 0;\n}\n\nvar activeMark = /*@__PURE__*/Decoration.mark({\n  class: \"cm-lintRange cm-lintRange-active\"\n});\n\nfunction lintTooltip(view, pos, side) {\n  var _view$state$field = view.state.field(lintState),\n      diagnostics = _view$state$field.diagnostics;\n\n  var found = [],\n      stackStart = 2e8,\n      stackEnd = 0;\n  diagnostics.between(pos - (side < 0 ? 1 : 0), pos + (side > 0 ? 1 : 0), function (from, to, _ref2) {\n    var spec = _ref2.spec;\n\n    if (pos >= from && pos <= to && (from == to || (pos > from || side > 0) && (pos < to || side < 0))) {\n      found.push(spec.diagnostic);\n      stackStart = Math.min(from, stackStart);\n      stackEnd = Math.max(to, stackEnd);\n    }\n  });\n  var diagnosticFilter = view.state.facet(lintConfig).tooltipFilter;\n  if (diagnosticFilter) found = diagnosticFilter(found);\n  if (!found.length) return null;\n  return {\n    pos: stackStart,\n    end: stackEnd,\n    above: view.state.doc.lineAt(stackStart).to < stackEnd,\n    create: function create() {\n      return {\n        dom: diagnosticsTooltip(view, found)\n      };\n    }\n  };\n}\n\nfunction diagnosticsTooltip(view, diagnostics) {\n  return elt(\"ul\", {\n    class: \"cm-tooltip-lint\"\n  }, diagnostics.map(function (d) {\n    return renderDiagnostic(view, d, false);\n  }));\n}\n/**\nCommand to open and focus the lint panel.\n*/\n\n\nvar openLintPanel = function openLintPanel(view) {\n  var field = view.state.field(lintState, false);\n  if (!field || !field.panel) view.dispatch({\n    effects: maybeEnableLint(view.state, [togglePanel.of(true)])\n  });\n  var panel = getPanel(view, LintPanel.open);\n  if (panel) panel.dom.querySelector(\".cm-panel-lint ul\").focus();\n  return true;\n};\n/**\nCommand to close the lint panel, when open.\n*/\n\n\nvar closeLintPanel = function closeLintPanel(view) {\n  var field = view.state.field(lintState, false);\n  if (!field || !field.panel) return false;\n  view.dispatch({\n    effects: togglePanel.of(false)\n  });\n  return true;\n};\n/**\nMove the selection to the next diagnostic.\n*/\n\n\nvar nextDiagnostic = function nextDiagnostic(view) {\n  var field = view.state.field(lintState, false);\n  if (!field) return false;\n  var sel = view.state.selection.main,\n      next = field.diagnostics.iter(sel.to + 1);\n\n  if (!next.value) {\n    next = field.diagnostics.iter(0);\n    if (!next.value || next.from == sel.from && next.to == sel.to) return false;\n  }\n\n  view.dispatch({\n    selection: {\n      anchor: next.from,\n      head: next.to\n    },\n    scrollIntoView: true\n  });\n  return true;\n};\n/**\nA set of default key bindings for the lint functionality.\n\n- Ctrl-Shift-m (Cmd-Shift-m on macOS): [`openLintPanel`](https://codemirror.net/6/docs/ref/#lint.openLintPanel)\n- F8: [`nextDiagnostic`](https://codemirror.net/6/docs/ref/#lint.nextDiagnostic)\n*/\n\n\nvar lintKeymap = [{\n  key: \"Mod-Shift-m\",\n  run: openLintPanel\n}, {\n  key: \"F8\",\n  run: nextDiagnostic\n}];\nvar lintPlugin = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class(view) {\n    _classCallCheck(this, _class);\n\n    this.view = view;\n    this.timeout = -1;\n    this.set = true;\n\n    var _view$state$facet = view.state.facet(lintConfig),\n        delay = _view$state$facet.delay;\n\n    this.lintTime = Date.now() + delay;\n    this.run = this.run.bind(this);\n    this.timeout = setTimeout(this.run, delay);\n  }\n\n  _createClass(_class, [{\n    key: \"run\",\n    value: function run() {\n      var _this = this;\n\n      var now = Date.now();\n\n      if (now < this.lintTime - 10) {\n        setTimeout(this.run, this.lintTime - now);\n      } else {\n        this.set = false;\n\n        var state = this.view.state,\n            _state$facet = state.facet(lintConfig),\n            sources = _state$facet.sources;\n\n        Promise.all(sources.map(function (source) {\n          return Promise.resolve(source(_this.view));\n        })).then(function (annotations) {\n          var all = annotations.reduce(function (a, b) {\n            return a.concat(b);\n          });\n          if (_this.view.state.doc == state.doc) _this.view.dispatch(setDiagnostics(_this.view.state, all));\n        }, function (error) {\n          logException(_this.view.state, error);\n        });\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(_update) {\n      var config = _update.state.facet(lintConfig);\n\n      if (_update.docChanged || config != _update.startState.facet(lintConfig)) {\n        this.lintTime = Date.now() + config.delay;\n\n        if (!this.set) {\n          this.set = true;\n          this.timeout = setTimeout(this.run, config.delay);\n        }\n      }\n    }\n  }, {\n    key: \"force\",\n    value: function force() {\n      if (this.set) {\n        this.lintTime = Date.now();\n        this.run();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      clearTimeout(this.timeout);\n    }\n  }]);\n\n  return _class;\n}());\nvar lintConfig = /*@__PURE__*/Facet.define({\n  combine: function combine(input) {\n    return Object.assign({\n      sources: input.map(function (i) {\n        return i.source;\n      })\n    }, combineConfig(input.map(function (i) {\n      return i.config;\n    }), {\n      delay: 750,\n      markerFilter: null,\n      tooltipFilter: null\n    }));\n  },\n  enables: lintPlugin\n});\n/**\nGiven a diagnostic source, this function returns an extension that\nenables linting with that source. It will be called whenever the\neditor is idle (after its content changed).\n*/\n\nfunction linter(source) {\n  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return lintConfig.of({\n    source: source,\n    config: config\n  });\n}\n/**\nForces any linters [configured](https://codemirror.net/6/docs/ref/#lint.linter) to run when the\neditor is idle to run right away.\n*/\n\n\nfunction forceLinting(view) {\n  var plugin = view.plugin(lintPlugin);\n  if (plugin) plugin.force();\n}\n\nfunction assignKeys(actions) {\n  var assigned = [];\n\n  if (actions) {\n    var _iterator2 = _createForOfIteratorHelper(actions),\n        _step2;\n\n    try {\n      actions: for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var name = _step2.value.name;\n\n        var _loop = function _loop(i) {\n          var ch = name[i];\n\n          if (/[a-zA-Z]/.test(ch) && !assigned.some(function (c) {\n            return c.toLowerCase() == ch.toLowerCase();\n          })) {\n            assigned.push(ch);\n            return \"continue|actions\";\n          }\n        };\n\n        for (var i = 0; i < name.length; i++) {\n          var _ret = _loop(i);\n\n          if (_ret === \"continue|actions\") continue actions;\n        }\n\n        assigned.push(\"\");\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  return assigned;\n}\n\nfunction renderDiagnostic(view, diagnostic, inPanel) {\n  var _a;\n\n  var keys = inPanel ? assignKeys(diagnostic.actions) : [];\n  return elt(\"li\", {\n    class: \"cm-diagnostic cm-diagnostic-\" + diagnostic.severity\n  }, elt(\"span\", {\n    class: \"cm-diagnosticText\"\n  }, diagnostic.renderMessage ? diagnostic.renderMessage() : diagnostic.message), (_a = diagnostic.actions) === null || _a === void 0 ? void 0 : _a.map(function (action, i) {\n    var click = function click(e) {\n      e.preventDefault();\n      var found = findDiagnostic(view.state.field(lintState).diagnostics, diagnostic);\n      if (found) action.apply(view, found.from, found.to);\n    };\n\n    var name = action.name,\n        keyIndex = keys[i] ? name.indexOf(keys[i]) : -1;\n    var nameElt = keyIndex < 0 ? name : [name.slice(0, keyIndex), elt(\"u\", name.slice(keyIndex, keyIndex + 1)), name.slice(keyIndex + 1)];\n    return elt(\"button\", {\n      type: \"button\",\n      class: \"cm-diagnosticAction\",\n      onclick: click,\n      onmousedown: click,\n      \"aria-label\": \" Action: \".concat(name).concat(keyIndex < 0 ? \"\" : \" (access key \\\"\".concat(keys[i], \")\\\"\"), \".\")\n    }, nameElt);\n  }), diagnostic.source && elt(\"div\", {\n    class: \"cm-diagnosticSource\"\n  }, diagnostic.source));\n}\n\nvar DiagnosticWidget = /*#__PURE__*/function (_WidgetType) {\n  _inherits(DiagnosticWidget, _WidgetType);\n\n  function DiagnosticWidget(diagnostic) {\n    var _this2;\n\n    _classCallCheck(this, DiagnosticWidget);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(DiagnosticWidget).call(this));\n    _this2.diagnostic = diagnostic;\n    return _this2;\n  }\n\n  _createClass(DiagnosticWidget, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return other.diagnostic == this.diagnostic;\n    }\n  }, {\n    key: \"toDOM\",\n    value: function toDOM() {\n      return elt(\"span\", {\n        class: \"cm-lintPoint cm-lintPoint-\" + this.diagnostic.severity\n      });\n    }\n  }]);\n\n  return DiagnosticWidget;\n}(WidgetType);\n\nvar PanelItem = function PanelItem(view, diagnostic) {\n  _classCallCheck(this, PanelItem);\n\n  this.diagnostic = diagnostic;\n  this.id = \"item_\" + Math.floor(Math.random() * 0xffffffff).toString(16);\n  this.dom = renderDiagnostic(view, diagnostic, true);\n  this.dom.id = this.id;\n  this.dom.setAttribute(\"role\", \"option\");\n};\n\nvar LintPanel = /*#__PURE__*/function () {\n  function LintPanel(view) {\n    var _this3 = this;\n\n    _classCallCheck(this, LintPanel);\n\n    this.view = view;\n    this.items = [];\n\n    var onkeydown = function onkeydown(event) {\n      if (event.keyCode == 27) {\n        // Escape\n        closeLintPanel(_this3.view);\n\n        _this3.view.focus();\n      } else if (event.keyCode == 38 || event.keyCode == 33) {\n        // ArrowUp, PageUp\n        _this3.moveSelection((_this3.selectedIndex - 1 + _this3.items.length) % _this3.items.length);\n      } else if (event.keyCode == 40 || event.keyCode == 34) {\n        // ArrowDown, PageDown\n        _this3.moveSelection((_this3.selectedIndex + 1) % _this3.items.length);\n      } else if (event.keyCode == 36) {\n        // Home\n        _this3.moveSelection(0);\n      } else if (event.keyCode == 35) {\n        // End\n        _this3.moveSelection(_this3.items.length - 1);\n      } else if (event.keyCode == 13) {\n        // Enter\n        _this3.view.focus();\n      } else if (event.keyCode >= 65 && event.keyCode <= 90 && _this3.selectedIndex >= 0) {\n        // A-Z\n        var diagnostic = _this3.items[_this3.selectedIndex].diagnostic,\n            keys = assignKeys(diagnostic.actions);\n\n        for (var i = 0; i < keys.length; i++) {\n          if (keys[i].toUpperCase().charCodeAt(0) == event.keyCode) {\n            var found = findDiagnostic(_this3.view.state.field(lintState).diagnostics, diagnostic);\n            if (found) diagnostic.actions[i].apply(view, found.from, found.to);\n          }\n        }\n      } else {\n        return;\n      }\n\n      event.preventDefault();\n    };\n\n    var onclick = function onclick(event) {\n      for (var i = 0; i < _this3.items.length; i++) {\n        if (_this3.items[i].dom.contains(event.target)) _this3.moveSelection(i);\n      }\n    };\n\n    this.list = elt(\"ul\", {\n      tabIndex: 0,\n      role: \"listbox\",\n      \"aria-label\": this.view.state.phrase(\"Diagnostics\"),\n      onkeydown: onkeydown,\n      onclick: onclick\n    });\n    this.dom = elt(\"div\", {\n      class: \"cm-panel-lint\"\n    }, this.list, elt(\"button\", {\n      type: \"button\",\n      name: \"close\",\n      \"aria-label\": this.view.state.phrase(\"close\"),\n      onclick: function onclick() {\n        return closeLintPanel(_this3.view);\n      }\n    }, \"Ã—\"));\n    this.update();\n  }\n\n  _createClass(LintPanel, [{\n    key: \"update\",\n    value: function update() {\n      var _this4 = this;\n\n      var _this$view$state$fiel = this.view.state.field(lintState),\n          diagnostics = _this$view$state$fiel.diagnostics,\n          selected = _this$view$state$fiel.selected;\n\n      var i = 0,\n          needsSync = false,\n          newSelectedItem = null;\n      diagnostics.between(0, this.view.state.doc.length, function (_start, _end, _ref3) {\n        var spec = _ref3.spec;\n        var found = -1,\n            item;\n\n        for (var j = i; j < _this4.items.length; j++) {\n          if (_this4.items[j].diagnostic == spec.diagnostic) {\n            found = j;\n            break;\n          }\n        }\n\n        if (found < 0) {\n          item = new PanelItem(_this4.view, spec.diagnostic);\n\n          _this4.items.splice(i, 0, item);\n\n          needsSync = true;\n        } else {\n          item = _this4.items[found];\n\n          if (found > i) {\n            _this4.items.splice(i, found - i);\n\n            needsSync = true;\n          }\n        }\n\n        if (selected && item.diagnostic == selected.diagnostic) {\n          if (!item.dom.hasAttribute(\"aria-selected\")) {\n            item.dom.setAttribute(\"aria-selected\", \"true\");\n            newSelectedItem = item;\n          }\n        } else if (item.dom.hasAttribute(\"aria-selected\")) {\n          item.dom.removeAttribute(\"aria-selected\");\n        }\n\n        i++;\n      });\n\n      while (i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0)) {\n        needsSync = true;\n        this.items.pop();\n      }\n\n      if (this.items.length == 0) {\n        this.items.push(new PanelItem(this.view, {\n          from: -1,\n          to: -1,\n          severity: \"info\",\n          message: this.view.state.phrase(\"No diagnostics\")\n        }));\n        needsSync = true;\n      }\n\n      if (newSelectedItem) {\n        this.list.setAttribute(\"aria-activedescendant\", newSelectedItem.id);\n        this.view.requestMeasure({\n          key: this,\n          read: function read() {\n            return {\n              sel: newSelectedItem.dom.getBoundingClientRect(),\n              panel: _this4.list.getBoundingClientRect()\n            };\n          },\n          write: function write(_ref4) {\n            var sel = _ref4.sel,\n                panel = _ref4.panel;\n            if (sel.top < panel.top) _this4.list.scrollTop -= panel.top - sel.top;else if (sel.bottom > panel.bottom) _this4.list.scrollTop += sel.bottom - panel.bottom;\n          }\n        });\n      } else if (this.selectedIndex < 0) {\n        this.list.removeAttribute(\"aria-activedescendant\");\n      }\n\n      if (needsSync) this.sync();\n    }\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      var domPos = this.list.firstChild;\n\n      function rm() {\n        var prev = domPos;\n        domPos = prev.nextSibling;\n        prev.remove();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(this.items),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var item = _step3.value;\n\n          if (item.dom.parentNode == this.list) {\n            while (domPos != item.dom) {\n              rm();\n            }\n\n            domPos = item.dom.nextSibling;\n          } else {\n            this.list.insertBefore(item.dom, domPos);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      while (domPos) {\n        rm();\n      }\n    }\n  }, {\n    key: \"moveSelection\",\n    value: function moveSelection(selectedIndex) {\n      if (this.selectedIndex < 0) return;\n      var field = this.view.state.field(lintState);\n      var selection = findDiagnostic(field.diagnostics, this.items[selectedIndex].diagnostic);\n      if (!selection) return;\n      this.view.dispatch({\n        selection: {\n          anchor: selection.from,\n          head: selection.to\n        },\n        scrollIntoView: true,\n        effects: movePanelSelection.of(selection)\n      });\n    }\n  }, {\n    key: \"selectedIndex\",\n    get: function get() {\n      var selected = this.view.state.field(lintState).selected;\n      if (!selected) return -1;\n\n      for (var i = 0; i < this.items.length; i++) {\n        if (this.items[i].diagnostic == selected.diagnostic) return i;\n      }\n\n      return -1;\n    }\n  }], [{\n    key: \"open\",\n    value: function open(view) {\n      return new LintPanel(view);\n    }\n  }]);\n\n  return LintPanel;\n}();\n\nfunction svg(content) {\n  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"viewBox=\\\"0 0 40 40\\\"\";\n  return \"url('data:image/svg+xml,<svg xmlns=\\\"http://www.w3.org/2000/svg\\\" \".concat(attrs, \">\").concat(encodeURIComponent(content), \"</svg>')\");\n}\n\nfunction underline(color) {\n  return svg(\"<path d=\\\"m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0\\\" stroke=\\\"\".concat(color, \"\\\" fill=\\\"none\\\" stroke-width=\\\".7\\\"/>\"), \"width=\\\"6\\\" height=\\\"3\\\"\");\n}\n\nvar baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-diagnostic\": {\n    padding: \"3px 6px 3px 8px\",\n    marginLeft: \"-1px\",\n    display: \"block\",\n    whiteSpace: \"pre-wrap\"\n  },\n  \".cm-diagnostic-error\": {\n    borderLeft: \"5px solid #d11\"\n  },\n  \".cm-diagnostic-warning\": {\n    borderLeft: \"5px solid orange\"\n  },\n  \".cm-diagnostic-info\": {\n    borderLeft: \"5px solid #999\"\n  },\n  \".cm-diagnosticAction\": {\n    font: \"inherit\",\n    border: \"none\",\n    padding: \"2px 4px\",\n    backgroundColor: \"#444\",\n    color: \"white\",\n    borderRadius: \"3px\",\n    marginLeft: \"8px\"\n  },\n  \".cm-diagnosticSource\": {\n    fontSize: \"70%\",\n    opacity: .7\n  },\n  \".cm-lintRange\": {\n    backgroundPosition: \"left bottom\",\n    backgroundRepeat: \"repeat-x\",\n    paddingBottom: \"0.7px\"\n  },\n  \".cm-lintRange-error\": {\n    backgroundImage: /*@__PURE__*/underline(\"#d11\")\n  },\n  \".cm-lintRange-warning\": {\n    backgroundImage: /*@__PURE__*/underline(\"orange\")\n  },\n  \".cm-lintRange-info\": {\n    backgroundImage: /*@__PURE__*/underline(\"#999\")\n  },\n  \".cm-lintRange-active\": {\n    backgroundColor: \"#ffdd9980\"\n  },\n  \".cm-tooltip-lint\": {\n    padding: 0,\n    margin: 0\n  },\n  \".cm-lintPoint\": {\n    position: \"relative\",\n    \"&:after\": {\n      content: '\"\"',\n      position: \"absolute\",\n      bottom: 0,\n      left: \"-2px\",\n      borderLeft: \"3px solid transparent\",\n      borderRight: \"3px solid transparent\",\n      borderBottom: \"4px solid #d11\"\n    }\n  },\n  \".cm-lintPoint-warning\": {\n    \"&:after\": {\n      borderBottomColor: \"orange\"\n    }\n  },\n  \".cm-lintPoint-info\": {\n    \"&:after\": {\n      borderBottomColor: \"#999\"\n    }\n  },\n  \".cm-panel.cm-panel-lint\": {\n    position: \"relative\",\n    \"& ul\": {\n      maxHeight: \"100px\",\n      overflowY: \"auto\",\n      \"& [aria-selected]\": {\n        backgroundColor: \"#ddd\",\n        \"& u\": {\n          textDecoration: \"underline\"\n        }\n      },\n      \"&:focus [aria-selected]\": {\n        background_fallback: \"#bdf\",\n        backgroundColor: \"Highlight\",\n        color_fallback: \"white\",\n        color: \"HighlightText\"\n      },\n      \"& u\": {\n        textDecoration: \"none\"\n      },\n      padding: 0,\n      margin: 0\n    },\n    \"& [name=close]\": {\n      position: \"absolute\",\n      top: \"0\",\n      right: \"2px\",\n      background: \"inherit\",\n      border: \"none\",\n      font: \"inherit\",\n      padding: 0,\n      margin: 0\n    }\n  }\n});\n\nvar LintGutterMarker = /*#__PURE__*/function (_GutterMarker) {\n  _inherits(LintGutterMarker, _GutterMarker);\n\n  function LintGutterMarker(diagnostics) {\n    var _this5;\n\n    _classCallCheck(this, LintGutterMarker);\n\n    _this5 = _possibleConstructorReturn(this, _getPrototypeOf(LintGutterMarker).call(this));\n    _this5.diagnostics = diagnostics;\n    _this5.severity = diagnostics.reduce(function (max, d) {\n      var s = d.severity;\n      return s == \"error\" || s == \"warning\" && max == \"info\" ? s : max;\n    }, \"info\");\n    return _this5;\n  }\n\n  _createClass(LintGutterMarker, [{\n    key: \"toDOM\",\n    value: function toDOM(view) {\n      var elt = document.createElement(\"div\");\n      elt.className = \"cm-lint-marker cm-lint-marker-\" + this.severity;\n      var diagnostics = this.diagnostics;\n      var diagnosticsFilter = view.state.facet(lintGutterConfig).tooltipFilter;\n      if (diagnosticsFilter) diagnostics = diagnosticsFilter(diagnostics);\n      if (diagnostics.length) elt.onmouseover = function () {\n        return gutterMarkerMouseOver(view, elt, diagnostics);\n      };\n      return elt;\n    }\n  }]);\n\n  return LintGutterMarker;\n}(GutterMarker);\n\nfunction trackHoverOn(view, marker) {\n  var mousemove = function mousemove(event) {\n    var rect = marker.getBoundingClientRect();\n    if (event.clientX > rect.left - 10\n    /* Margin */\n    && event.clientX < rect.right + 10\n    /* Margin */\n    && event.clientY > rect.top - 10\n    /* Margin */\n    && event.clientY < rect.bottom + 10\n    /* Margin */\n    ) return;\n\n    for (var target = event.target; target; target = target.parentNode) {\n      if (target.nodeType == 1 && target.classList.contains(\"cm-tooltip-lint\")) return;\n    }\n\n    window.removeEventListener(\"mousemove\", mousemove);\n    if (view.state.field(lintGutterTooltip)) view.dispatch({\n      effects: setLintGutterTooltip.of(null)\n    });\n  };\n\n  window.addEventListener(\"mousemove\", mousemove);\n}\n\nfunction gutterMarkerMouseOver(view, marker, diagnostics) {\n  function hovered() {\n    var line = view.elementAtHeight(marker.getBoundingClientRect().top + 5 - view.documentTop);\n    var linePos = view.coordsAtPos(line.from);\n\n    if (linePos) {\n      view.dispatch({\n        effects: setLintGutterTooltip.of({\n          pos: line.from,\n          above: false,\n          create: function create() {\n            return {\n              dom: diagnosticsTooltip(view, diagnostics),\n              getCoords: function getCoords() {\n                return marker.getBoundingClientRect();\n              }\n            };\n          }\n        })\n      });\n    }\n\n    marker.onmouseout = marker.onmousemove = null;\n    trackHoverOn(view, marker);\n  }\n\n  var _view$state$facet2 = view.state.facet(lintGutterConfig),\n      hoverTime = _view$state$facet2.hoverTime;\n\n  var hoverTimeout = setTimeout(hovered, hoverTime);\n\n  marker.onmouseout = function () {\n    clearTimeout(hoverTimeout);\n    marker.onmouseout = marker.onmousemove = null;\n  };\n\n  marker.onmousemove = function () {\n    clearTimeout(hoverTimeout);\n    hoverTimeout = setTimeout(hovered, hoverTime);\n  };\n}\n\nfunction markersForDiagnostics(doc, diagnostics) {\n  var byLine = Object.create(null);\n\n  var _iterator4 = _createForOfIteratorHelper(diagnostics),\n      _step4;\n\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var diagnostic = _step4.value;\n\n      var _line = doc.lineAt(diagnostic.from);\n\n      (byLine[_line.from] || (byLine[_line.from] = [])).push(diagnostic);\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n\n  var markers = [];\n\n  for (var line in byLine) {\n    markers.push(new LintGutterMarker(byLine[line]).range(+line));\n  }\n\n  return RangeSet.of(markers, true);\n}\n\nvar lintGutterExtension = /*@__PURE__*/gutter({\n  class: \"cm-gutter-lint\",\n  markers: function markers(view) {\n    return view.state.field(lintGutterMarkers);\n  }\n});\nvar lintGutterMarkers = /*@__PURE__*/StateField.define({\n  create: function create() {\n    return RangeSet.empty;\n  },\n  update: function update(markers, tr) {\n    markers = markers.map(tr.changes);\n    var diagnosticFilter = tr.state.facet(lintGutterConfig).markerFilter;\n\n    var _iterator5 = _createForOfIteratorHelper(tr.effects),\n        _step5;\n\n    try {\n      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n        var effect = _step5.value;\n\n        if (effect.is(setDiagnosticsEffect)) {\n          var diagnostics = effect.value;\n          if (diagnosticFilter) diagnostics = diagnosticFilter(diagnostics || []);\n          markers = markersForDiagnostics(tr.state.doc, diagnostics.slice(0));\n        }\n      }\n    } catch (err) {\n      _iterator5.e(err);\n    } finally {\n      _iterator5.f();\n    }\n\n    return markers;\n  }\n});\nvar setLintGutterTooltip = /*@__PURE__*/StateEffect.define();\nvar lintGutterTooltip = /*@__PURE__*/StateField.define({\n  create: function create() {\n    return null;\n  },\n  update: function update(tooltip, tr) {\n    if (tooltip && tr.docChanged) tooltip = hideTooltip(tr, tooltip) ? null : Object.assign(Object.assign({}, tooltip), {\n      pos: tr.changes.mapPos(tooltip.pos)\n    });\n    return tr.effects.reduce(function (t, e) {\n      return e.is(setLintGutterTooltip) ? e.value : t;\n    }, tooltip);\n  },\n  provide: function provide(field) {\n    return showTooltip.from(field);\n  }\n});\nvar lintGutterTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-gutter-lint\": {\n    width: \"1.4em\",\n    \"& .cm-gutterElement\": {\n      padding: \".2em\"\n    }\n  },\n  \".cm-lint-marker\": {\n    width: \"1em\",\n    height: \"1em\"\n  },\n  \".cm-lint-marker-info\": {\n    content: /*@__PURE__*/svg(\"<path fill=\\\"#aaf\\\" stroke=\\\"#77e\\\" stroke-width=\\\"6\\\" stroke-linejoin=\\\"round\\\" d=\\\"M5 5L35 5L35 35L5 35Z\\\"/>\")\n  },\n  \".cm-lint-marker-warning\": {\n    content: /*@__PURE__*/svg(\"<path fill=\\\"#fe8\\\" stroke=\\\"#fd7\\\" stroke-width=\\\"6\\\" stroke-linejoin=\\\"round\\\" d=\\\"M20 6L37 35L3 35Z\\\"/>\")\n  },\n  \".cm-lint-marker-error:before\": {\n    content: /*@__PURE__*/svg(\"<circle cx=\\\"20\\\" cy=\\\"20\\\" r=\\\"15\\\" fill=\\\"#f87\\\" stroke=\\\"#f43\\\" stroke-width=\\\"6\\\"/>\")\n  }\n});\nvar lintGutterConfig = /*@__PURE__*/Facet.define({\n  combine: function combine(configs) {\n    return combineConfig(configs, {\n      hoverTime: 300\n      /* Time */\n      ,\n      markerFilter: null,\n      tooltipFilter: null\n    });\n  }\n});\n/**\nReturns an extension that installs a gutter showing markers for\neach line that has diagnostics, which can be hovered over to see\nthe diagnostics.\n*/\n\nfunction lintGutter() {\n  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return [lintGutterConfig.of(config), lintGutterMarkers, lintGutterExtension, lintGutterTheme, lintGutterTooltip];\n}\n\nexport { closeLintPanel, diagnosticCount, forceLinting, lintGutter, lintKeymap, linter, nextDiagnostic, openLintPanel, setDiagnostics, setDiagnosticsEffect };","map":null,"metadata":{},"sourceType":"module"}
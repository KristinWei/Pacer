{"ast":null,"code":"import _toConsumableArray from \"/Users/kw/Desktop/cscc09/project-pacer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _possibleConstructorReturn from \"/Users/kw/Desktop/cscc09/project-pacer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/kw/Desktop/cscc09/project-pacer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/kw/Desktop/cscc09/project-pacer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _slicedToArray from \"/Users/kw/Desktop/cscc09/project-pacer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _classCallCheck from \"/Users/kw/Desktop/cscc09/project-pacer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/kw/Desktop/cscc09/project-pacer/frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { showPanel, EditorView, getPanel, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { codePointAt, fromCodePoint, codePointSize, StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, RangeSetBuilder, Prec } from '@codemirror/state';\nimport elt from 'crelt';\nvar basicNormalize = typeof String.prototype.normalize == \"function\" ? function (x) {\n  return x.normalize(\"NFKD\");\n} : function (x) {\n  return x;\n};\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\n\nvar SearchCursor = /*#__PURE__*/function () {\n  /**\n  Create a text cursor. The query is the search string, `from` to\n  `to` provides the region to search.\n  \n  When `normalize` is given, it will be called, on both the query\n  string and the content it is matched against, before comparing.\n  You can, for example, create a case-insensitive search by\n  passing `s => s.toLowerCase()`.\n  \n  Text is always normalized with\n  [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n  (when supported).\n  */\n  function SearchCursor(text, query) {\n    var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var to = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : text.length;\n    var normalize = arguments.length > 4 ? arguments[4] : undefined;\n\n    _classCallCheck(this, SearchCursor);\n\n    /**\n    The current match (only holds a meaningful value after\n    [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n    `done` is false).\n    */\n    this.value = {\n      from: 0,\n      to: 0\n    };\n    /**\n    Whether the end of the iterated region has been reached.\n    */\n\n    this.done = false;\n    this.matches = [];\n    this.buffer = \"\";\n    this.bufferPos = 0;\n    this.iter = text.iterRange(from, to);\n    this.bufferStart = from;\n    this.normalize = normalize ? function (x) {\n      return normalize(basicNormalize(x));\n    } : basicNormalize;\n    this.query = this.normalize(query);\n  }\n\n  _createClass(SearchCursor, [{\n    key: \"peek\",\n    value: function peek() {\n      if (this.bufferPos == this.buffer.length) {\n        this.bufferStart += this.buffer.length;\n        this.iter.next();\n        if (this.iter.done) return -1;\n        this.bufferPos = 0;\n        this.buffer = this.iter.value;\n      }\n\n      return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      while (this.matches.length) {\n        this.matches.pop();\n      }\n\n      return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n\n  }, {\n    key: \"nextOverlapping\",\n    value: function nextOverlapping() {\n      for (;;) {\n        var next = this.peek();\n\n        if (next < 0) {\n          this.done = true;\n          return this;\n        }\n\n        var str = fromCodePoint(next),\n            start = this.bufferStart + this.bufferPos;\n        this.bufferPos += codePointSize(next);\n        var norm = this.normalize(str);\n\n        for (var i = 0, pos = start;; i++) {\n          var code = norm.charCodeAt(i);\n          var match = this.match(code, pos);\n\n          if (match) {\n            this.value = match;\n            return this;\n          }\n\n          if (i == norm.length - 1) break;\n          if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;\n        }\n      }\n    }\n  }, {\n    key: \"match\",\n    value: function match(code, pos) {\n      var match = null;\n\n      for (var i = 0; i < this.matches.length; i += 2) {\n        var index = this.matches[i],\n            keep = false;\n\n        if (this.query.charCodeAt(index) == code) {\n          if (index == this.query.length - 1) {\n            match = {\n              from: this.matches[i + 1],\n              to: pos + 1\n            };\n          } else {\n            this.matches[i]++;\n            keep = true;\n          }\n        }\n\n        if (!keep) {\n          this.matches.splice(i, 2);\n          i -= 2;\n        }\n      }\n\n      if (this.query.charCodeAt(0) == code) {\n        if (this.query.length == 1) match = {\n          from: pos,\n          to: pos + 1\n        };else this.matches.push(1, pos);\n      }\n\n      return match;\n    }\n  }]);\n\n  return SearchCursor;\n}();\n\nif (typeof Symbol != \"undefined\") SearchCursor.prototype[Symbol.iterator] = function () {\n  return this;\n};\nvar empty = {\n  from: -1,\n  to: -1,\n  match: /*@__PURE__*/ /.*/.exec(\"\")\n};\nvar baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\n\nvar RegExpCursor = /*#__PURE__*/function () {\n  /**\n  Create a cursor that will search the given range in the given\n  document. `query` should be the raw pattern (as you'd pass it to\n  `new RegExp`).\n  */\n  function RegExpCursor(text, query, options) {\n    var from = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    var to = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : text.length;\n\n    _classCallCheck(this, RegExpCursor);\n\n    this.to = to;\n    this.curLine = \"\";\n    /**\n    Set to `true` when the cursor has reached the end of the search\n    range.\n    */\n\n    this.done = false;\n    /**\n    Will contain an object with the extent of the match and the\n    match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n    sucessfully finds a match.\n    */\n\n    this.value = empty;\n    if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);\n    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n    this.iter = text.iter();\n    var startLine = text.lineAt(from);\n    this.curLineStart = startLine.from;\n    this.matchPos = from;\n    this.getLine(this.curLineStart);\n  }\n\n  _createClass(RegExpCursor, [{\n    key: \"getLine\",\n    value: function getLine(skip) {\n      this.iter.next(skip);\n\n      if (this.iter.lineBreak) {\n        this.curLine = \"\";\n      } else {\n        this.curLine = this.iter.value;\n        if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n        this.iter.next();\n      }\n    }\n  }, {\n    key: \"nextLine\",\n    value: function nextLine() {\n      this.curLineStart = this.curLineStart + this.curLine.length + 1;\n      if (this.curLineStart > this.to) this.curLine = \"\";else this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n\n  }, {\n    key: \"next\",\n    value: function next() {\n      for (var off = this.matchPos - this.curLineStart;;) {\n        this.re.lastIndex = off;\n        var match = this.matchPos <= this.to && this.re.exec(this.curLine);\n\n        if (match) {\n          var from = this.curLineStart + match.index,\n              to = from + match[0].length;\n          this.matchPos = to + (from == to ? 1 : 0);\n          if (from == this.curLine.length) this.nextLine();\n\n          if (from < to || from > this.value.to) {\n            this.value = {\n              from: from,\n              to: to,\n              match: match\n            };\n            return this;\n          }\n\n          off = this.matchPos - this.curLineStart;\n        } else if (this.curLineStart + this.curLine.length < this.to) {\n          this.nextLine();\n          off = 0;\n        } else {\n          this.done = true;\n          return this;\n        }\n      }\n    }\n  }]);\n\n  return RegExpCursor;\n}();\n\nvar flattened = /*@__PURE__*/new WeakMap(); // Reusable (partially) flattened document strings\n\nvar FlattenedDoc = /*#__PURE__*/function () {\n  function FlattenedDoc(from, text) {\n    _classCallCheck(this, FlattenedDoc);\n\n    this.from = from;\n    this.text = text;\n  }\n\n  _createClass(FlattenedDoc, [{\n    key: \"to\",\n    get: function get() {\n      return this.from + this.text.length;\n    }\n  }], [{\n    key: \"get\",\n    value: function get(doc, from, to) {\n      var cached = flattened.get(doc);\n\n      if (!cached || cached.from >= to || cached.to <= from) {\n        var flat = new FlattenedDoc(from, doc.sliceString(from, to));\n        flattened.set(doc, flat);\n        return flat;\n      }\n\n      if (cached.from == from && cached.to == to) return cached;\n      var text = cached.text,\n          cachedFrom = cached.from;\n\n      if (cachedFrom > from) {\n        text = doc.sliceString(from, cachedFrom) + text;\n        cachedFrom = from;\n      }\n\n      if (cached.to < to) text += doc.sliceString(cached.to, to);\n      flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n      return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n  }]);\n\n  return FlattenedDoc;\n}();\n\nvar MultilineRegExpCursor = /*#__PURE__*/function () {\n  function MultilineRegExpCursor(text, query, options, from, to) {\n    _classCallCheck(this, MultilineRegExpCursor);\n\n    this.text = text;\n    this.to = to;\n    this.done = false;\n    this.value = empty;\n    this.matchPos = from;\n    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000\n    /* Base */\n    ));\n  }\n\n  _createClass(MultilineRegExpCursor, [{\n    key: \"chunkEnd\",\n    value: function chunkEnd(pos) {\n      return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n  }, {\n    key: \"next\",\n    value: function next() {\n      for (;;) {\n        var off = this.re.lastIndex = this.matchPos - this.flat.from;\n        var match = this.re.exec(this.flat.text); // Skip empty matches directly after the last match\n\n        if (match && !match[0] && match.index == off) {\n          this.re.lastIndex = off + 1;\n          match = this.re.exec(this.flat.text);\n        } // If a match goes almost to the end of a noncomplete chunk, try\n        // again, since it'll likely be able to match more\n\n\n        if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10) match = null;\n\n        if (match) {\n          var from = this.flat.from + match.index,\n              to = from + match[0].length;\n          this.value = {\n            from: from,\n            to: to,\n            match: match\n          };\n          this.matchPos = to + (from == to ? 1 : 0);\n          return this;\n        } else {\n          if (this.flat.to == this.to) {\n            this.done = true;\n            return this;\n          } // Grow the flattened doc\n\n\n          this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n      }\n    }\n  }]);\n\n  return MultilineRegExpCursor;\n}();\n\nif (typeof Symbol != \"undefined\") {\n  RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] = function () {\n    return this;\n  };\n}\n\nfunction validRegExp(source) {\n  try {\n    new RegExp(source, baseFlags);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n\nfunction createLineDialog(view) {\n  var input = elt(\"input\", {\n    class: \"cm-textfield\",\n    name: \"line\"\n  });\n  var dom = elt(\"form\", {\n    class: \"cm-gotoLine\",\n    onkeydown: function onkeydown(event) {\n      if (event.keyCode == 27) {\n        // Escape\n        event.preventDefault();\n        view.dispatch({\n          effects: dialogEffect.of(false)\n        });\n        view.focus();\n      } else if (event.keyCode == 13) {\n        // Enter\n        event.preventDefault();\n        go();\n      }\n    },\n    onsubmit: function onsubmit(event) {\n      event.preventDefault();\n      go();\n    }\n  }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", {\n    class: \"cm-button\",\n    type: \"submit\"\n  }, view.state.phrase(\"go\")));\n\n  function go() {\n    var match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n    if (!match) return;\n    var state = view.state,\n        startLine = state.doc.lineAt(state.selection.main.head);\n\n    var _match = _slicedToArray(match, 5),\n        sign = _match[1],\n        ln = _match[2],\n        cl = _match[3],\n        percent = _match[4];\n\n    var col = cl ? +cl.slice(1) : 0;\n    var line = ln ? +ln : startLine.number;\n\n    if (ln && percent) {\n      var pc = line / 100;\n      if (sign) pc = pc * (sign == \"-\" ? -1 : 1) + startLine.number / state.doc.lines;\n      line = Math.round(state.doc.lines * pc);\n    } else if (ln && sign) {\n      line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n    }\n\n    var docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n    view.dispatch({\n      effects: dialogEffect.of(false),\n      selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\n      scrollIntoView: true\n    });\n    view.focus();\n  }\n\n  return {\n    dom: dom\n  };\n}\n\nvar dialogEffect = /*@__PURE__*/StateEffect.define();\nvar dialogField = /*@__PURE__*/StateField.define({\n  create: function create() {\n    return true;\n  },\n  update: function update(value, tr) {\n    var _iterator = _createForOfIteratorHelper(tr.effects),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var e = _step.value;\n        if (e.is(dialogEffect)) value = e.value;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return value;\n  },\n  provide: function provide(f) {\n    return showPanel.from(f, function (val) {\n      return val ? createLineDialog : null;\n    });\n  }\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n\nThe dialog can be styled with the `panel.gotoLine` theme\nselector.\n*/\n\nvar gotoLine = function gotoLine(view) {\n  var panel = getPanel(view, createLineDialog);\n\n  if (!panel) {\n    var effects = [dialogEffect.of(true)];\n    if (view.state.field(dialogField, false) == null) effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n    view.dispatch({\n      effects: effects\n    });\n    panel = getPanel(view, createLineDialog);\n  }\n\n  if (panel) panel.dom.querySelector(\"input\").focus();\n  return true;\n};\n\nvar baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-panel.cm-gotoLine\": {\n    padding: \"2px 6px 4px\",\n    \"& label\": {\n      fontSize: \"80%\"\n    }\n  }\n});\nvar defaultHighlightOptions = {\n  highlightWordAroundCursor: false,\n  minSelectionLength: 1,\n  maxMatches: 100,\n  wholeWords: false\n};\nvar highlightConfig = /*@__PURE__*/Facet.define({\n  combine: function combine(options) {\n    return combineConfig(options, defaultHighlightOptions, {\n      highlightWordAroundCursor: function highlightWordAroundCursor(a, b) {\n        return a || b;\n      },\n      minSelectionLength: Math.min,\n      maxMatches: Math.min\n    });\n  }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\n\nfunction highlightSelectionMatches(options) {\n  var ext = [defaultTheme, matchHighlighter];\n  if (options) ext.push(highlightConfig.of(options));\n  return ext;\n}\n\nvar matchDeco = /*@__PURE__*/Decoration.mark({\n  class: \"cm-selectionMatch\"\n});\nvar mainMatchDeco = /*@__PURE__*/Decoration.mark({\n  class: \"cm-selectionMatch cm-selectionMatch-main\"\n}); // Whether the characters directly outside the given positions are non-word characters\n\nfunction insideWordBoundaries(check, state, from, to) {\n  return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);\n} // Whether the characters directly at the given positions are word characters\n\n\nfunction insideWord(check, state, from, to) {\n  return check(state.sliceDoc(from, from + 1)) == CharCategory.Word && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;\n}\n\nvar matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class(view) {\n    _classCallCheck(this, _class);\n\n    this.decorations = this.getDeco(view);\n  }\n\n  _createClass(_class, [{\n    key: \"update\",\n    value: function update(_update) {\n      if (_update.selectionSet || _update.docChanged || _update.viewportChanged) this.decorations = this.getDeco(_update.view);\n    }\n  }, {\n    key: \"getDeco\",\n    value: function getDeco(view) {\n      var conf = view.state.facet(highlightConfig);\n      var state = view.state,\n          sel = state.selection;\n      if (sel.ranges.length > 1) return Decoration.none;\n      var range = sel.main,\n          query,\n          check = null;\n\n      if (range.empty) {\n        if (!conf.highlightWordAroundCursor) return Decoration.none;\n        var word = state.wordAt(range.head);\n        if (!word) return Decoration.none;\n        check = state.charCategorizer(range.head);\n        query = state.sliceDoc(word.from, word.to);\n      } else {\n        var len = range.to - range.from;\n        if (len < conf.minSelectionLength || len > 200) return Decoration.none;\n\n        if (conf.wholeWords) {\n          query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n\n          check = state.charCategorizer(range.head);\n          if (!(insideWordBoundaries(check, state, range.from, range.to) && insideWord(check, state, range.from, range.to))) return Decoration.none;\n        } else {\n          query = state.sliceDoc(range.from, range.to).trim();\n          if (!query) return Decoration.none;\n        }\n      }\n\n      var deco = [];\n\n      var _iterator2 = _createForOfIteratorHelper(view.visibleRanges),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var part = _step2.value;\n          var cursor = new SearchCursor(state.doc, query, part.from, part.to);\n\n          while (!cursor.next().done) {\n            var _cursor$value = cursor.value,\n                from = _cursor$value.from,\n                to = _cursor$value.to;\n\n            if (!check || insideWordBoundaries(check, state, from, to)) {\n              if (range.empty && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));\n              if (deco.length > conf.maxMatches) return Decoration.none;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return Decoration.set(deco);\n    }\n  }]);\n\n  return _class;\n}(), {\n  decorations: function decorations(v) {\n    return v.decorations;\n  }\n});\nvar defaultTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-selectionMatch\": {\n    backgroundColor: \"#99ff7780\"\n  },\n  \".cm-searchMatch .cm-selectionMatch\": {\n    backgroundColor: \"transparent\"\n  }\n}); // Select the words around the cursors.\n\nvar selectWord = function selectWord(_ref) {\n  var state = _ref.state,\n      dispatch = _ref.dispatch;\n  var selection = state.selection;\n  var newSel = EditorSelection.create(selection.ranges.map(function (range) {\n    return state.wordAt(range.head) || EditorSelection.cursor(range.head);\n  }), selection.mainIndex);\n  if (newSel.eq(selection)) return false;\n  dispatch(state.update({\n    selection: newSel\n  }));\n  return true;\n}; // Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\n\n\nfunction findNextOccurrence(state, query) {\n  var _state$selection = state.selection,\n      main = _state$selection.main,\n      ranges = _state$selection.ranges;\n  var word = state.wordAt(main.head),\n      fullWord = word && word.from == main.from && word.to == main.to;\n\n  var _loop = function _loop(_cycled, _cursor) {\n    _cursor.next();\n\n    if (_cursor.done) {\n      if (_cycled) {\n        cursor = _cursor;\n        {\n          cycled = _cycled;\n          return {\n            v: null\n          };\n        }\n      }\n\n      _cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n      _cycled = true;\n    } else {\n      if (_cycled && ranges.some(function (r) {\n        return r.from == _cursor.value.from;\n      })) {\n        cursor = _cursor;\n        {\n          cycled = _cycled;\n          return \"continue\";\n        }\n      }\n\n      if (fullWord) {\n        var _word = state.wordAt(_cursor.value.from);\n\n        if (!_word || _word.from != _cursor.value.from || _word.to != _cursor.value.to) {\n          cursor = _cursor;\n          {\n            cycled = _cycled;\n            return \"continue\";\n          }\n        }\n      }\n\n      cycled = _cycled;\n      cursor = _cursor;\n      return {\n        v: _cursor.value\n      };\n    }\n\n    cycled = _cycled;\n    cursor = _cursor;\n  };\n\n  for (var cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n    var _ret = _loop(cycled, cursor);\n\n    if (_ret === \"continue\") continue;\n    if (typeof _ret === \"object\") return _ret.v;\n  }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/\n\n\nvar selectNextOccurrence = function selectNextOccurrence(_ref2) {\n  var state = _ref2.state,\n      dispatch = _ref2.dispatch;\n  var ranges = state.selection.ranges;\n  if (ranges.some(function (sel) {\n    return sel.from === sel.to;\n  })) return selectWord({\n    state: state,\n    dispatch: dispatch\n  });\n  var searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n  if (state.selection.ranges.some(function (r) {\n    return state.sliceDoc(r.from, r.to) != searchedText;\n  })) return false;\n  var range = findNextOccurrence(state, searchedText);\n  if (!range) return false;\n  dispatch(state.update({\n    selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),\n    effects: EditorView.scrollIntoView(range.to)\n  }));\n  return true;\n};\n\nvar searchConfigFacet = /*@__PURE__*/Facet.define({\n  combine: function combine(configs) {\n    var _a;\n\n    return {\n      top: configs.reduce(function (val, conf) {\n        return val !== null && val !== void 0 ? val : conf.top;\n      }, undefined) || false,\n      caseSensitive: configs.reduce(function (val, conf) {\n        return val !== null && val !== void 0 ? val : conf.caseSensitive;\n      }, undefined) || false,\n      createPanel: ((_a = configs.find(function (c) {\n        return c.createPanel;\n      })) === null || _a === void 0 ? void 0 : _a.createPanel) || function (view) {\n        return new SearchPanel(view);\n      }\n    };\n  }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/\n\nfunction search(config) {\n  return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/\n\n\nvar SearchQuery = /*#__PURE__*/function () {\n  /**\n  Create a query object.\n  */\n  function SearchQuery(config) {\n    _classCallCheck(this, SearchQuery);\n\n    this.search = config.search;\n    this.caseSensitive = !!config.caseSensitive;\n    this.regexp = !!config.regexp;\n    this.replace = config.replace || \"\";\n    this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n    this.unquoted = config.literal ? this.search : this.search.replace(/\\\\([nrt\\\\])/g, function (_, ch) {\n      return ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\";\n    });\n  }\n  /**\n  Compare this query to another query.\n  */\n\n\n  _createClass(SearchQuery, [{\n    key: \"eq\",\n    value: function eq(other) {\n      return this.search == other.search && this.replace == other.replace && this.caseSensitive == other.caseSensitive && this.regexp == other.regexp;\n    }\n    /**\n    @internal\n    */\n\n  }, {\n    key: \"create\",\n    value: function create() {\n      return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given document.\n    */\n\n  }, {\n    key: \"getCursor\",\n    value: function getCursor(doc) {\n      var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var to = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : doc.length;\n      return this.regexp ? regexpCursor(this, doc, from, to) : stringCursor(this, doc, from, to);\n    }\n  }]);\n\n  return SearchQuery;\n}();\n\nvar QueryType = function QueryType(spec) {\n  _classCallCheck(this, QueryType);\n\n  this.spec = spec;\n};\n\nfunction stringCursor(spec, doc, from, to) {\n  return new SearchCursor(doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : function (x) {\n    return x.toLowerCase();\n  });\n}\n\nvar StringQuery = /*#__PURE__*/function (_QueryType) {\n  _inherits(StringQuery, _QueryType);\n\n  function StringQuery(spec) {\n    _classCallCheck(this, StringQuery);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(StringQuery).call(this, spec));\n  }\n\n  _createClass(StringQuery, [{\n    key: \"nextMatch\",\n    value: function nextMatch(doc, curFrom, curTo) {\n      var cursor = stringCursor(this.spec, doc, curTo, doc.length).nextOverlapping();\n      if (cursor.done) cursor = stringCursor(this.spec, doc, 0, curFrom).nextOverlapping();\n      return cursor.done ? null : cursor.value;\n    } // Searching in reverse is, rather than implementing inverted search\n    // cursor, done by scanning chunk after chunk forward.\n\n  }, {\n    key: \"prevMatchInRange\",\n    value: function prevMatchInRange(doc, from, to) {\n      for (var pos = to;;) {\n        var start = Math.max(from, pos - 10000\n        /* ChunkSize */\n        - this.spec.unquoted.length);\n\n        var _cursor2 = stringCursor(this.spec, doc, start, pos),\n            range = null;\n\n        while (!_cursor2.nextOverlapping().done) {\n          range = _cursor2.value;\n        }\n\n        if (range) return range;\n        if (start == from) return null;\n        pos -= 10000\n        /* ChunkSize */\n        ;\n      }\n    }\n  }, {\n    key: \"prevMatch\",\n    value: function prevMatch(doc, curFrom, curTo) {\n      return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);\n    }\n  }, {\n    key: \"getReplacement\",\n    value: function getReplacement(_result) {\n      return this.spec.replace;\n    }\n  }, {\n    key: \"matchAll\",\n    value: function matchAll(doc, limit) {\n      var cursor = stringCursor(this.spec, doc, 0, doc.length),\n          ranges = [];\n\n      while (!cursor.next().done) {\n        if (ranges.length >= limit) return null;\n        ranges.push(cursor.value);\n      }\n\n      return ranges;\n    }\n  }, {\n    key: \"highlight\",\n    value: function highlight(doc, from, to, add) {\n      var cursor = stringCursor(this.spec, doc, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, doc.length));\n\n      while (!cursor.next().done) {\n        add(cursor.value.from, cursor.value.to);\n      }\n    }\n  }]);\n\n  return StringQuery;\n}(QueryType);\n\nfunction regexpCursor(spec, doc, from, to) {\n  return new RegExpCursor(doc, spec.search, spec.caseSensitive ? undefined : {\n    ignoreCase: true\n  }, from, to);\n}\n\nvar RegExpQuery = /*#__PURE__*/function (_QueryType2) {\n  _inherits(RegExpQuery, _QueryType2);\n\n  function RegExpQuery() {\n    _classCallCheck(this, RegExpQuery);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(RegExpQuery).apply(this, arguments));\n  }\n\n  _createClass(RegExpQuery, [{\n    key: \"nextMatch\",\n    value: function nextMatch(doc, curFrom, curTo) {\n      var cursor = regexpCursor(this.spec, doc, curTo, doc.length).next();\n      if (cursor.done) cursor = regexpCursor(this.spec, doc, 0, curFrom).next();\n      return cursor.done ? null : cursor.value;\n    }\n  }, {\n    key: \"prevMatchInRange\",\n    value: function prevMatchInRange(doc, from, to) {\n      for (var size = 1;; size++) {\n        var start = Math.max(from, to - size * 10000\n        /* ChunkSize */\n        );\n\n        var _cursor3 = regexpCursor(this.spec, doc, start, to),\n            range = null;\n\n        while (!_cursor3.next().done) {\n          range = _cursor3.value;\n        }\n\n        if (range && (start == from || range.from > start + 10)) return range;\n        if (start == from) return null;\n      }\n    }\n  }, {\n    key: \"prevMatch\",\n    value: function prevMatch(doc, curFrom, curTo) {\n      return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);\n    }\n  }, {\n    key: \"getReplacement\",\n    value: function getReplacement(result) {\n      return this.spec.replace.replace(/\\$([$&\\d+])/g, function (m, i) {\n        return i == \"$\" ? \"$\" : i == \"&\" ? result.match[0] : i != \"0\" && +i < result.match.length ? result.match[i] : m;\n      });\n    }\n  }, {\n    key: \"matchAll\",\n    value: function matchAll(doc, limit) {\n      var cursor = regexpCursor(this.spec, doc, 0, doc.length),\n          ranges = [];\n\n      while (!cursor.next().done) {\n        if (ranges.length >= limit) return null;\n        ranges.push(cursor.value);\n      }\n\n      return ranges;\n    }\n  }, {\n    key: \"highlight\",\n    value: function highlight(doc, from, to, add) {\n      var cursor = regexpCursor(this.spec, doc, Math.max(0, from - 250\n      /* HighlightMargin */\n      ), Math.min(to + 250\n      /* HighlightMargin */\n      , doc.length));\n\n      while (!cursor.next().done) {\n        add(cursor.value.from, cursor.value.to);\n      }\n    }\n  }]);\n\n  return RegExpQuery;\n}(QueryType);\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/\n\n\nvar setSearchQuery = /*@__PURE__*/StateEffect.define();\nvar togglePanel = /*@__PURE__*/StateEffect.define();\nvar searchState = /*@__PURE__*/StateField.define({\n  create: function create(state) {\n    return new SearchState(defaultQuery(state).create(), null);\n  },\n  update: function update(value, tr) {\n    var _iterator3 = _createForOfIteratorHelper(tr.effects),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var effect = _step3.value;\n        if (effect.is(setSearchQuery)) value = new SearchState(effect.value.create(), value.panel);else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return value;\n  },\n  provide: function provide(f) {\n    return showPanel.from(f, function (val) {\n      return val.panel;\n    });\n  }\n});\n/**\nGet the current search query from an editor state.\n*/\n\nfunction getSearchQuery(state) {\n  var curState = state.field(searchState, false);\n  return curState ? curState.query.spec : defaultQuery(state);\n}\n\nvar SearchState = function SearchState(query, panel) {\n  _classCallCheck(this, SearchState);\n\n  this.query = query;\n  this.panel = panel;\n};\n\nvar matchMark = /*@__PURE__*/Decoration.mark({\n  class: \"cm-searchMatch\"\n}),\n    selectedMatchMark = /*@__PURE__*/Decoration.mark({\n  class: \"cm-searchMatch cm-searchMatch-selected\"\n});\nvar searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass( /*#__PURE__*/function () {\n  function _class2(view) {\n    _classCallCheck(this, _class2);\n\n    this.view = view;\n    this.decorations = this.highlight(view.state.field(searchState));\n  }\n\n  _createClass(_class2, [{\n    key: \"update\",\n    value: function update(_update2) {\n      var state = _update2.state.field(searchState);\n\n      if (state != _update2.startState.field(searchState) || _update2.docChanged || _update2.selectionSet || _update2.viewportChanged) this.decorations = this.highlight(state);\n    }\n  }, {\n    key: \"highlight\",\n    value: function highlight(_ref3) {\n      var query = _ref3.query,\n          panel = _ref3.panel;\n      if (!panel || !query.spec.valid) return Decoration.none;\n      var view = this.view;\n      var builder = new RangeSetBuilder();\n\n      for (var i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n        var _ranges$i = ranges[i],\n            from = _ranges$i.from,\n            to = _ranges$i.to;\n\n        while (i < l - 1 && to > ranges[i + 1].from - 2 * 250\n        /* HighlightMargin */\n        ) {\n          to = ranges[++i].to;\n        }\n\n        query.highlight(view.state.doc, from, to, function (from, to) {\n          var selected = view.state.selection.ranges.some(function (r) {\n            return r.from == from && r.to == to;\n          });\n          builder.add(from, to, selected ? selectedMatchMark : matchMark);\n        });\n      }\n\n      return builder.finish();\n    }\n  }]);\n\n  return _class2;\n}(), {\n  decorations: function decorations(v) {\n    return v.decorations;\n  }\n});\n\nfunction searchCommand(f) {\n  return function (view) {\n    var state = view.state.field(searchState, false);\n    return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n  };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\n\n\nvar findNext = /*@__PURE__*/searchCommand(function (view, _ref4) {\n  var query = _ref4.query;\n  var _view$state$selection = view.state.selection.main,\n      from = _view$state$selection.from,\n      to = _view$state$selection.to;\n  var next = query.nextMatch(view.state.doc, from, to);\n  if (!next || next.from == from && next.to == to) return false;\n  view.dispatch({\n    selection: {\n      anchor: next.from,\n      head: next.to\n    },\n    scrollIntoView: true,\n    effects: announceMatch(view, next),\n    userEvent: \"select.search\"\n  });\n  return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\n\nvar findPrevious = /*@__PURE__*/searchCommand(function (view, _ref5) {\n  var query = _ref5.query;\n  var state = view.state,\n      _state$selection$main = state.selection.main,\n      from = _state$selection$main.from,\n      to = _state$selection$main.to;\n  var range = query.prevMatch(state.doc, from, to);\n  if (!range) return false;\n  view.dispatch({\n    selection: {\n      anchor: range.from,\n      head: range.to\n    },\n    scrollIntoView: true,\n    effects: announceMatch(view, range),\n    userEvent: \"select.search\"\n  });\n  return true;\n});\n/**\nSelect all instances of the search query.\n*/\n\nvar selectMatches = /*@__PURE__*/searchCommand(function (view, _ref6) {\n  var query = _ref6.query;\n  var ranges = query.matchAll(view.state.doc, 1000);\n  if (!ranges || !ranges.length) return false;\n  view.dispatch({\n    selection: EditorSelection.create(ranges.map(function (r) {\n      return EditorSelection.range(r.from, r.to);\n    })),\n    userEvent: \"select.search.matches\"\n  });\n  return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\n\nvar selectSelectionMatches = function selectSelectionMatches(_ref7) {\n  var state = _ref7.state,\n      dispatch = _ref7.dispatch;\n  var sel = state.selection;\n  if (sel.ranges.length > 1 || sel.main.empty) return false;\n  var _sel$main = sel.main,\n      from = _sel$main.from,\n      to = _sel$main.to;\n  var ranges = [],\n      main = 0;\n\n  for (var cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n    if (ranges.length > 1000) return false;\n    if (cur.value.from == from) main = ranges.length;\n    ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n  }\n\n  dispatch(state.update({\n    selection: EditorSelection.create(ranges, main),\n    userEvent: \"select.search.matches\"\n  }));\n  return true;\n};\n/**\nReplace the current match of the search query.\n*/\n\n\nvar replaceNext = /*@__PURE__*/searchCommand(function (view, _ref8) {\n  var query = _ref8.query;\n  var state = view.state,\n      _state$selection$main2 = state.selection.main,\n      from = _state$selection$main2.from,\n      to = _state$selection$main2.to;\n  if (state.readOnly) return false;\n  var next = query.nextMatch(state.doc, from, from);\n  if (!next) return false;\n  var changes = [],\n      selection,\n      replacement;\n  var announce = [];\n\n  if (next.from == from && next.to == to) {\n    replacement = state.toText(query.getReplacement(next));\n    changes.push({\n      from: next.from,\n      to: next.to,\n      insert: replacement\n    });\n    next = query.nextMatch(state.doc, next.from, next.to);\n    announce.push(EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n  }\n\n  if (next) {\n    var off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n    selection = {\n      anchor: next.from - off,\n      head: next.to - off\n    };\n    announce.push(announceMatch(view, next));\n  }\n\n  view.dispatch({\n    changes: changes,\n    selection: selection,\n    scrollIntoView: !!selection,\n    effects: announce,\n    userEvent: \"input.replace\"\n  });\n  return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\n\nvar replaceAll = /*@__PURE__*/searchCommand(function (view, _ref9) {\n  var query = _ref9.query;\n  if (view.state.readOnly) return false;\n  var changes = query.matchAll(view.state.doc, 1e9).map(function (match) {\n    var from = match.from,\n        to = match.to;\n    return {\n      from: from,\n      to: to,\n      insert: query.getReplacement(match)\n    };\n  });\n  if (!changes.length) return false;\n  var announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n  view.dispatch({\n    changes: changes,\n    effects: EditorView.announce.of(announceText),\n    userEvent: \"input.replace.all\"\n  });\n  return true;\n});\n\nfunction createSearchPanel(view) {\n  return view.state.facet(searchConfigFacet).createPanel(view);\n}\n\nfunction defaultQuery(state, fallback) {\n  var _a;\n\n  var sel = state.selection.main;\n  var selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n  var caseSensitive = (_a = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _a !== void 0 ? _a : state.facet(searchConfigFacet).caseSensitive;\n  return fallback && !selText ? fallback : new SearchQuery({\n    search: selText.replace(/\\n/g, \"\\\\n\"),\n    caseSensitive: caseSensitive\n  });\n}\n/**\nMake sure the search panel is open and focused.\n*/\n\n\nvar openSearchPanel = function openSearchPanel(view) {\n  var state = view.state.field(searchState, false);\n\n  if (state && state.panel) {\n    var panel = getPanel(view, createSearchPanel);\n    if (!panel) return false;\n    var searchInput = panel.dom.querySelector(\"[main-field]\");\n\n    if (searchInput && searchInput != view.root.activeElement) {\n      var query = defaultQuery(view.state, state.query.spec);\n      if (query.valid) view.dispatch({\n        effects: setSearchQuery.of(query)\n      });\n      searchInput.focus();\n      searchInput.select();\n    }\n  } else {\n    view.dispatch({\n      effects: [togglePanel.of(true), state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)]\n    });\n  }\n\n  return true;\n};\n/**\nClose the search panel.\n*/\n\n\nvar closeSearchPanel = function closeSearchPanel(view) {\n  var state = view.state.field(searchState, false);\n  if (!state || !state.panel) return false;\n  var panel = getPanel(view, createSearchPanel);\n  if (panel && panel.dom.contains(view.root.activeElement)) view.focus();\n  view.dispatch({\n    effects: togglePanel.of(false)\n  });\n  return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\n\n\nvar searchKeymap = [{\n  key: \"Mod-f\",\n  run: openSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"F3\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\",\n  preventDefault: true\n}, {\n  key: \"Mod-g\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\",\n  preventDefault: true\n}, {\n  key: \"Escape\",\n  run: closeSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Mod-Shift-l\",\n  run: selectSelectionMatches\n}, {\n  key: \"Alt-g\",\n  run: gotoLine\n}, {\n  key: \"Mod-d\",\n  run: selectNextOccurrence,\n  preventDefault: true\n}];\n\nvar SearchPanel = /*#__PURE__*/function () {\n  function SearchPanel(view) {\n    var _this = this;\n\n    _classCallCheck(this, SearchPanel);\n\n    this.view = view;\n    var query = this.query = view.state.field(searchState).query.spec;\n    this.commit = this.commit.bind(this);\n    this.searchField = elt(\"input\", {\n      value: query.search,\n      placeholder: phrase(view, \"Find\"),\n      \"aria-label\": phrase(view, \"Find\"),\n      class: \"cm-textfield\",\n      name: \"search\",\n      \"main-field\": \"true\",\n      onchange: this.commit,\n      onkeyup: this.commit\n    });\n    this.replaceField = elt(\"input\", {\n      value: query.replace,\n      placeholder: phrase(view, \"Replace\"),\n      \"aria-label\": phrase(view, \"Replace\"),\n      class: \"cm-textfield\",\n      name: \"replace\",\n      onchange: this.commit,\n      onkeyup: this.commit\n    });\n    this.caseField = elt(\"input\", {\n      type: \"checkbox\",\n      name: \"case\",\n      checked: query.caseSensitive,\n      onchange: this.commit\n    });\n    this.reField = elt(\"input\", {\n      type: \"checkbox\",\n      name: \"re\",\n      checked: query.regexp,\n      onchange: this.commit\n    });\n\n    function button(name, onclick, content) {\n      return elt(\"button\", {\n        class: \"cm-button\",\n        name: name,\n        onclick: onclick,\n        type: \"button\"\n      }, content);\n    }\n\n    this.dom = elt(\"div\", {\n      onkeydown: function onkeydown(e) {\n        return _this.keydown(e);\n      },\n      class: \"cm-search\"\n    }, [this.searchField, button(\"next\", function () {\n      return findNext(view);\n    }, [phrase(view, \"next\")]), button(\"prev\", function () {\n      return findPrevious(view);\n    }, [phrase(view, \"previous\")]), button(\"select\", function () {\n      return selectMatches(view);\n    }, [phrase(view, \"all\")]), elt(\"label\", null, [this.caseField, phrase(view, \"match case\")]), elt(\"label\", null, [this.reField, phrase(view, \"regexp\")])].concat(_toConsumableArray(view.state.readOnly ? [] : [elt(\"br\"), this.replaceField, button(\"replace\", function () {\n      return replaceNext(view);\n    }, [phrase(view, \"replace\")]), button(\"replaceAll\", function () {\n      return replaceAll(view);\n    }, [phrase(view, \"replace all\")]), elt(\"button\", {\n      name: \"close\",\n      onclick: function onclick() {\n        return closeSearchPanel(view);\n      },\n      \"aria-label\": phrase(view, \"close\"),\n      type: \"button\"\n    }, [\"×\"])])));\n  }\n\n  _createClass(SearchPanel, [{\n    key: \"commit\",\n    value: function commit() {\n      var query = new SearchQuery({\n        search: this.searchField.value,\n        caseSensitive: this.caseField.checked,\n        regexp: this.reField.checked,\n        replace: this.replaceField.value\n      });\n\n      if (!query.eq(this.query)) {\n        this.query = query;\n        this.view.dispatch({\n          effects: setSearchQuery.of(query)\n        });\n      }\n    }\n  }, {\n    key: \"keydown\",\n    value: function keydown(e) {\n      if (runScopeHandlers(this.view, e, \"search-panel\")) {\n        e.preventDefault();\n      } else if (e.keyCode == 13 && e.target == this.searchField) {\n        e.preventDefault();\n        (e.shiftKey ? findPrevious : findNext)(this.view);\n      } else if (e.keyCode == 13 && e.target == this.replaceField) {\n        e.preventDefault();\n        replaceNext(this.view);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(_update3) {\n      var _iterator4 = _createForOfIteratorHelper(_update3.transactions),\n          _step4;\n\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var tr = _step4.value;\n\n          var _iterator5 = _createForOfIteratorHelper(tr.effects),\n              _step5;\n\n          try {\n            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n              var effect = _step5.value;\n              if (effect.is(setSearchQuery) && !effect.value.eq(this.query)) this.setQuery(effect.value);\n            }\n          } catch (err) {\n            _iterator5.e(err);\n          } finally {\n            _iterator5.f();\n          }\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n    }\n  }, {\n    key: \"setQuery\",\n    value: function setQuery(query) {\n      this.query = query;\n      this.searchField.value = query.search;\n      this.replaceField.value = query.replace;\n      this.caseField.checked = query.caseSensitive;\n      this.reField.checked = query.regexp;\n    }\n  }, {\n    key: \"mount\",\n    value: function mount() {\n      this.searchField.select();\n    }\n  }, {\n    key: \"pos\",\n    get: function get() {\n      return 80;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this.view.state.facet(searchConfigFacet).top;\n    }\n  }]);\n\n  return SearchPanel;\n}();\n\nfunction phrase(view, phrase) {\n  return view.state.phrase(phrase);\n}\n\nvar AnnounceMargin = 30;\nvar Break = /[\\s\\.,:;?!]/;\n\nfunction announceMatch(view, _ref10) {\n  var from = _ref10.from,\n      to = _ref10.to;\n  var line = view.state.doc.lineAt(from),\n      lineEnd = view.state.doc.lineAt(to).to;\n  var start = Math.max(line.from, from - AnnounceMargin),\n      end = Math.min(lineEnd, to + AnnounceMargin);\n  var text = view.state.sliceDoc(start, end);\n\n  if (start != line.from) {\n    for (var i = 0; i < AnnounceMargin; i++) {\n      if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n        text = text.slice(i);\n        break;\n      }\n    }\n  }\n\n  if (end != lineEnd) {\n    for (var _i = text.length - 1; _i > text.length - AnnounceMargin; _i--) {\n      if (!Break.test(text[_i - 1]) && Break.test(text[_i])) {\n        text = text.slice(0, _i);\n        break;\n      }\n    }\n  }\n\n  return EditorView.announce.of(\"\".concat(view.state.phrase(\"current match\"), \". \").concat(text, \" \").concat(view.state.phrase(\"on line\"), \" \").concat(line.number, \".\"));\n}\n\nvar baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-panel.cm-search\": {\n    padding: \"2px 6px 4px\",\n    position: \"relative\",\n    \"& [name=close]\": {\n      position: \"absolute\",\n      top: \"0\",\n      right: \"4px\",\n      backgroundColor: \"inherit\",\n      border: \"none\",\n      font: \"inherit\",\n      padding: 0,\n      margin: 0\n    },\n    \"& input, & button, & label\": {\n      margin: \".2em .6em .2em 0\"\n    },\n    \"& input[type=checkbox]\": {\n      marginRight: \".2em\"\n    },\n    \"& label\": {\n      fontSize: \"80%\",\n      whiteSpace: \"pre\"\n    }\n  },\n  \"&light .cm-searchMatch\": {\n    backgroundColor: \"#ffff0054\"\n  },\n  \"&dark .cm-searchMatch\": {\n    backgroundColor: \"#00ffff8a\"\n  },\n  \"&light .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff6a0054\"\n  },\n  \"&dark .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff00ff8a\"\n  }\n});\nvar searchExtensions = [searchState, /*@__PURE__*/Prec.lowest(searchHighlighter), baseTheme];\nexport { RegExpCursor, SearchCursor, SearchQuery, closeSearchPanel, findNext, findPrevious, getSearchQuery, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, search, searchKeymap, selectMatches, selectNextOccurrence, selectSelectionMatches, setSearchQuery };","map":null,"metadata":{},"sourceType":"module"}